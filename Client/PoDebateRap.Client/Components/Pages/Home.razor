@page "/"
@using PoDebateRap.Shared.Models
@using PoDebateRap.Shared.Analyzers
@using PoDebateRap.Client.Components.Debate
@using Microsoft.JSInterop
@using System.Net.Http.Json

@inject HttpClient Http
@inject ILogger<Home> Logger
@inject IJSRuntime JSRuntime
@inject NotificationService NotificationService
@inject TooltipService TooltipService
@implements IDisposable

<PageTitle>PoDebateRap</PageTitle>

<!-- Crowd Reaction Overlay -->
<CrowdReaction ReactionType="_currentReactionType" 
               IsActive="_showCrowdReaction" 
               Score="_currentReactionScore"
               OnAnimationComplete="OnCrowdReactionComplete" />

<div class="page-container">
    <!-- Header Section -->
    <div class="header-section">
        <h1 class="main-title">PoDebateRap</h1>
        <p class="subtitle">AI-Powered Rap Battle Arena</p>
    </div>

    @* Display loading error if any *@
    @if (LoadingErrorMessage is { Length: > 0 })
    {
        <div class="alert alert-error" role="alert">
            <span class="alert-icon">‚ö†Ô∏è</span>
            <div class="alert-content">
                <strong>Error Loading Application</strong>
                <p>@LoadingErrorMessage</p>
            </div>
        </div>
    }

    <!-- Collapsible Setup Section -->
    <div class="setup-wrapper @(_isSetupCollapsed ? "collapsed" : "")">
        @if (!_isSetupCollapsed)
        {
            <DebateSetup Rappers="Rappers"
                     @bind-SelectedRapper1Name="SelectedRapper1Name"
                     @bind-SelectedRapper2Name="SelectedRapper2Name"
                     @bind-DebateTopicInput="DebateTopicInput"
                     @bind-DebateTopicInput:after="OnTopicChanged"
                     IsDisabled="@(IsLoading || _latestDebateState.IsGeneratingTurn || _latestDebateState.IsDebateInProgress)"
                     IsLoading="IsLoading"
                     IsStarting="_latestDebateState.IsGeneratingTurn"
                     IsFetchingTopic="IsFetchingInitialTopic"
                     IsDebateInProgress="_latestDebateState.IsDebateInProgress"
                     IsVoting="ShowVotingModal"
                     IsStartDisabled="IsStartDisabled()"
                     InitialTopicFetchError="InitialTopicFetchError"
                     TopicPlaceholder="@(IsFetchingInitialTopic ? "Fetching news topic..." : "Enter debate topic...")"
                     OnStartDebate="StartDebate"
                     OnStopDebate="StopDebate"
                     OnQuickBattle="QuickBattle" />
        }
        else
        {
            <!-- Collapsed Summary Bar -->
            <div class="setup-collapsed-summary" @onclick="ToggleSetup">
                <div class="summary-content">
                    <span class="summary-icon">‚öîÔ∏è</span>
                    <span class="summary-text">
                        <strong>@(_latestDebateState.Rapper1?.Name ?? "Rapper 1")</strong> vs 
                        <strong>@(_latestDebateState.Rapper2?.Name ?? "Rapper 2")</strong>
                        @if (_latestDebateState.Topic?.Title is { Length: > 0 } topicTitle)
                        {
                            <span class="summary-topic">- @topicTitle</span>
                        }
                    </span>
                </div>
                <button class="toggle-btn" title="Expand setup">
                    <span>‚ñº</span>
                </button>
            </div>
        }
    </div>

    <!-- Floating Action Button (shows when setup is collapsed and debate finished) -->
    @if (_isSetupCollapsed && !_latestDebateState.IsDebateInProgress)
    {
        <button class="fab-new-debate" @onclick="StartNewDebate" title="Start New Debate">
            <span class="fab-icon">‚ûï</span>
            <span class="fab-text">New Debate</span>
        </button>
    }

    <!-- Debate Arena Section -->
    <div class="debate-arena-container">
        @if (_latestDebateState.IsDebateInProgress || _latestDebateState.IsDebateFinished)
        {
            <DebateVisualizer Rapper1="@_latestDebateState.Rapper1"
                              Rapper2="@_latestDebateState.Rapper2"
                              CurrentTurnText="@GetDisplayedTurnText()"
                              IsRapper1Active="@GetDisplayedIsRapper1Active()"
                              IsRapper2Active="@(!GetDisplayedIsRapper1Active())"
                              CurrentTurnNumber="@GetDisplayedTurnNumber()"
                              TotalTurns="@_latestDebateState.TotalTurns"
                              ShowNavigation="@_latestDebateState.IsDebateFinished"
                              OnTurnChanged="HandleTurnNavigation" />
            
            <!-- Inline Results Section -->
            @if (ShowVotingModal && _latestDebateState.IsDebateFinished)
            {
                <DebateResults Topic="@_latestDebateState.Topic"
                               Rapper1Name="@_latestDebateState.Rapper1?.Name"
                               Rapper2Name="@_latestDebateState.Rapper2?.Name"
                               WinnerName="@_latestDebateState.WinnerName"
                               JudgeReasoning="@_latestDebateState.JudgeReasoning"
                               Stats="@_latestDebateState.Stats"
                               RhymeAnalytics="@_latestDebateState.RhymeAnalytics" />
            }
        }
        else
        {
            <div class="empty-state">
                <div class="empty-state-icon">üé§</div>
                <h3>Ready to Battle?</h3>
                <p>Enter a topic and click START BATTLE</p>
            </div>
        }
    </div>

</div> @* End page-container *@



@code {
    private DotNetObjectReference<Home>? objRef;
    private DebateState _latestDebateState = CreateEmptyDebateState();
    private int _lastPlayedTurnNumber = -1; // Track which turn's audio we've already played
    private bool _isSetupCollapsed = false; // Track collapse state
    
    // Turn history for navigation
    private record TurnHistory(int TurnNumber, string TurnText, bool IsRapper1Turn);
    private List<TurnHistory> _turnHistory = new();
    private int _displayedTurnNumber = 0; // Track which turn is currently displayed (0 = live)

    // Crowd reaction state
    private CrowdReactionType _currentReactionType = CrowdReactionType.None;
    private bool _showCrowdReaction = false;
    private double _currentReactionScore = 0;
    private int _lastReactionTurn = -1; // Track which turn we showed a reaction for

    private List<Rapper>? Rappers;
    private string? SelectedRapper1Name;
    private string? SelectedRapper2Name;
    
    // Use backing field to ensure StateHasChanged is called when topic changes
    private string _debateTopicInput = "";
    private string DebateTopicInput 
    { 
        get => _debateTopicInput;
        set
        {
            if (_debateTopicInput != value)
            {
                _debateTopicInput = value;
                Console.WriteLine($"[Home] DebateTopicInput property setter called with: '{value}'");
                StateHasChanged(); // Force re-render to update button state
            }
        }
    }

    private bool IsLoading = true;
    private bool IsFetchingInitialTopic = false;
    private string? LoadingErrorMessage = null;
#pragma warning disable CS0414 // Field is used - passed to DebateSetup component parameter
    private string? InitialTopicFetchError = null;
#pragma warning restore CS0414

    private bool ShowVotingModal = false;

    protected override async Task OnInitializedAsync()
    {
        objRef = DotNetObjectReference.Create(this);
        Logger.LogInformation("Home page initializing.");
        IsLoading = true;
        IsFetchingInitialTopic = true;
        LoadingErrorMessage = null;
        InitialTopicFetchError = null;
        StateHasChanged();

        try
        {
            // Add timeout and better error handling for Rappers API
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
            
            Rappers = await Http.GetFromJsonAsync<List<Rapper>>("api/Rappers", cts.Token);
            Logger.LogDebug("Retrieved {LoadedRapperCount} rappers.", Rappers?.Count ?? 0);
            
            // Add detailed logging for debugging
            if (Rappers != null && Rappers.Count > 0)
            {
                Logger.LogInformation("Successfully loaded {Count} rappers: {RapperNames}", 
                    Rappers.Count, 
                    string.Join(", ", Rappers.Select(r => $"'{r.Name}'")));
            }
            else
            {
                Logger.LogWarning("Rappers list is null or empty after API call");
            }
            
            if (Rappers == null || Rappers.Count == 0)
            {
                 LoadingErrorMessage = "Rapper list is empty. Check server connection and data seeding.";
                 Logger.LogWarning(LoadingErrorMessage);
            }

            try
            {
                var headlines = await Http.GetFromJsonAsync<List<NewsHeadline>>("api/News/headlines", cts.Token);
                if (headlines != null && headlines.Count > 0 && !string.IsNullOrWhiteSpace(headlines[0].Title))
                {
                    DebateTopicInput = headlines[0].Title!.Trim();
                    InitialTopicFetchError = null;
                    Logger.LogInformation("Pre-populated topic from news: {NewsTopic}", DebateTopicInput);
                }
                else
                {
                    // Leave blank for user to fill in
                    DebateTopicInput = "";
                    InitialTopicFetchError = "No news topics available. Please enter a topic manually.";
                    Logger.LogWarning("News API returned no headlines or headline had no title.");
                }
            }
            catch (HttpRequestException httpEx)
            {
                 Logger.LogError(httpEx, "HTTP error fetching initial news topic from API.");
                 // Leave blank for user to fill in
                 DebateTopicInput = "";
                 InitialTopicFetchError = "News service unavailable. Please enter a topic manually.";
            }
            catch (TaskCanceledException)
            {
                 Logger.LogError("Timeout fetching initial news topic from API.");
                 // Leave blank for user to fill in
                 DebateTopicInput = "";
                 InitialTopicFetchError = "News service timeout. Please enter a topic manually.";
            }
            catch (Exception newsEx)
            {
                 Logger.LogError(newsEx, "Error fetching initial news topic from API.");
                 // Leave blank for user to fill in
                 DebateTopicInput = "";
                 InitialTopicFetchError = "Could not fetch news topic. Please enter a topic manually.";
            }
        }
        catch (HttpRequestException httpEx)
        {
            Logger.LogError(httpEx, "HTTP error loading initial data for Home page.");
            LoadingErrorMessage = $"Could not connect to server: {httpEx.Message}. Please check if the API server is running.";
        }
        catch (TaskCanceledException)
        {
            Logger.LogError("Timeout loading initial data for Home page.");
            LoadingErrorMessage = "Server request timed out. Please check your connection and try again.";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading initial data for Home page.");
            LoadingErrorMessage = $"Error loading initial data: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
            IsFetchingInitialTopic = false;
            StateHasChanged();
        }
    }

    private async Task PollDebateState()
    {
        try
        {
            var newState = await Http.GetFromJsonAsync<DebateState>("api/Debate/current");

            if (newState == null)
            {
                Logger.LogWarning("Received null debate state from API. Stopping polling.");
                _latestDebateState = CreateEmptyDebateState(); // Reset state
                LoadingErrorMessage = "Debate state could not be retrieved.";
                await InvokeAsync(StateHasChanged);
                return;
            }

            _latestDebateState = newState;
            Logger.LogInformation("Received state update. Turn: {Turn}, IsGenerating: {IsGenerating}, Winner: {Winner}, CurrentTurnText length: {TextLength}",
                newState.CurrentTurnNumber, newState.IsGeneratingTurn, newState.WinnerName ?? "N/A", newState.CurrentTurnText?.Length ?? 0);

            // Capture turn history for navigation (only if it's a new turn with content)
            if (newState.CurrentTurnNumber > 0 && 
                !string.IsNullOrEmpty(newState.CurrentTurnText) &&
                !_turnHistory.Any(t => t.TurnNumber == newState.CurrentTurnNumber))
            {
                _turnHistory.Add(new TurnHistory(
                    newState.CurrentTurnNumber,
                    newState.CurrentTurnText,
                    newState.IsRapper1Turn
                ));
                Logger.LogInformation("üìö Captured turn {Turn} in history. Total turns stored: {Count}", 
                    newState.CurrentTurnNumber, _turnHistory.Count);
            }
            
            // Reset to live view when new turn comes in
            if (_displayedTurnNumber != 0 && _displayedTurnNumber != newState.CurrentTurnNumber)
            {
                _displayedTurnNumber = 0; // Back to live view
            }

            // Log audio data info
            if (newState.CurrentTurnAudio != null)
            {
                Logger.LogInformation("üéµ Audio data present: Length={Length} bytes", newState.CurrentTurnAudio.Length);
                
                // Log first 50 bytes for debugging
                if (newState.CurrentTurnAudio.Length > 0)
                {
                    var first50 = string.Join(" ", newState.CurrentTurnAudio.Take(50).Select(b => b.ToString("X2")));
                    Logger.LogInformation("üîç First 50 bytes received: {Bytes}", first50);
                }
            }
            else
            {
                Logger.LogWarning("‚ö†Ô∏è No audio data in state");
            }

            // Only play audio if this is a new turn we haven't played yet
            if (newState.CurrentTurnAudio != null && newState.CurrentTurnAudio.Length > 0 && objRef != null && newState.CurrentTurnNumber != _lastPlayedTurnNumber)
            {
                Logger.LogInformation("üéµ Audio data received for turn {Turn} (length: {AudioLength}), attempting playback via JS interop.", newState.CurrentTurnNumber, newState.CurrentTurnAudio.Length);
                
                // Trigger haptic feedback for turn transition
                try
                {
                    await JSRuntime.InvokeVoidAsync("haptic.notification");
                }
                catch { /* Haptic not supported */ }
                
                try
                {
                    var base64Audio = Convert.ToBase64String(newState.CurrentTurnAudio);
                    Logger.LogInformation("üéµ Converted to base64, length: {Base64Length}", base64Audio.Length);
                    await JSRuntime.InvokeVoidAsync("playAudio", objRef, base64Audio);
                    _lastPlayedTurnNumber = newState.CurrentTurnNumber; // Mark this turn as played
                    Logger.LogInformation("‚úÖ JS playAudio invoked successfully");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "‚ùå Error invoking JS for audio playback for turn {Turn}. Signaling completion.", newState.CurrentTurnNumber);
                    await NotifyAudioPlaybackComplete();
                }
            }
            else if (newState.CurrentTurnNumber == _lastPlayedTurnNumber && newState.CurrentTurnAudio != null)
            {
                Logger.LogDebug("‚è≠Ô∏è Skipping audio playback for turn {Turn} - already played", newState.CurrentTurnNumber);
            }
            else if (newState.IsDebateInProgress && newState.CurrentTurnNumber > 0)
            {
                Logger.LogInformation("No audio data for turn {Turn} or audio length is zero. Signaling completion immediately.", newState.CurrentTurnNumber);
                await NotifyAudioPlaybackComplete();
            }
            else if (newState.IsDebateInProgress && newState.CurrentTurnNumber == 0)
            {
                Logger.LogInformation("Initial state received (Turn 0), no audio expected yet. Waiting for first turn.");
            }
            else
            {
                Logger.LogInformation("No audio data and not in progress. No action needed for audio playback.");
            }

            if (!string.IsNullOrEmpty(newState.ErrorMessage))
            {
                 Logger.LogError("Error from orchestrator: {Error}", newState.ErrorMessage);
                 // TODO: Show error message in UI
            }

            await InvokeAsync(StateHasChanged);

            Logger.LogInformation("PollDebateState: Checking polling condition. IsDebateInProgress: {DS}, IsDebateFinished: {IDF}",
                _latestDebateState.IsDebateInProgress, newState.IsDebateFinished);
            if (_latestDebateState.IsDebateInProgress && !newState.IsDebateFinished)
            {
                Logger.LogInformation("PollDebateState: Scheduling next poll.");
                _ = Task.Delay(1000).ContinueWith(async _ => await PollDebateState());
            }
            else
            {
                Logger.LogInformation("PollDebateState: Not scheduling next poll. IsDebateInProgress: {DS}, IsDebateFinished: {IDF}",
                    _latestDebateState.IsDebateInProgress, newState.IsDebateFinished);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error polling debate state.");
            _latestDebateState = CreateEmptyDebateState(); // Reset state
            LoadingErrorMessage = $"Error during debate: {ex.Message}";
            await InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task NotifyAudioPlaybackComplete()
    {
        Logger.LogInformation("NotifyAudioPlaybackComplete called from JavaScript.");
        try
        {
            // Trigger crowd reaction for the completed turn
            await TriggerCrowdReactionAsync();

            Logger.LogInformation("Signaling audio playback complete to server.");
            var response = await Http.PatchAsync("api/Debate/current/audio-status", null);
            response.EnsureSuccessStatusCode();
            Logger.LogInformation("Server acknowledged audio playback complete.");

            if (_latestDebateState.IsDebateFinished)
            {
                Logger.LogInformation("Audio playback complete AND debate is finished. Showing results modal.");
                ShowVotingModal = true;
                
                // Show victory notification
                var winnerName = !string.IsNullOrEmpty(_latestDebateState.WinnerName) 
                    ? _latestDebateState.WinnerName 
                    : "It's a tie!";
                NotificationService.Notify(NotificationSeverity.Success, "üèÜ Battle Complete!", 
                    !string.IsNullOrEmpty(_latestDebateState.WinnerName) ? $"{winnerName} wins!" : winnerName, 5000);
                
                // Trigger victory haptic feedback
                try
                {
                    await JSRuntime.InvokeVoidAsync("haptic.victory");
                }
                catch { /* Haptic not supported */ }
                
                await InvokeAsync(StateHasChanged);
                
                // Scroll to results section
                try
                {
                    await Task.Delay(100); // Small delay to ensure DOM is updated
                    await JSRuntime.InvokeVoidAsync("scrollToElement", "debate-results");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error scrolling to results.");
                }
            }
            else if (_latestDebateState.IsDebateInProgress)
            {
                _ = Task.Run(async () => await PollDebateState());
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error signaling audio playback completion to orchestrator.");
        }
    }

    private async Task TriggerCrowdReactionAsync()
    {
        // Only trigger if we have turn analytics and haven't shown reaction for this turn
        if (_latestDebateState.CurrentTurnAnalytics != null && 
            _latestDebateState.CurrentTurnNumber > 0 &&
            _latestDebateState.CurrentTurnNumber != _lastReactionTurn)
        {
            _currentReactionType = _latestDebateState.CurrentTurnAnalytics.GetReactionType();
            _currentReactionScore = _latestDebateState.CurrentTurnAnalytics.OverallScore;
            _showCrowdReaction = true;
            _lastReactionTurn = _latestDebateState.CurrentTurnNumber;

            Logger.LogInformation("üé≠ Triggering crowd reaction: {Reaction} (Score: {Score}) for turn {Turn}",
                _currentReactionType, _currentReactionScore, _latestDebateState.CurrentTurnNumber);

            await InvokeAsync(StateHasChanged);
        }
    }

    private void OnCrowdReactionComplete()
    {
        _showCrowdReaction = false;
        _currentReactionType = CrowdReactionType.None;
        StateHasChanged();
    }

    private bool IsStartDisabled()
    {
        Console.WriteLine($"[Home] IsStartDisabled called. Topic: '{DebateTopicInput}', Rapper1: '{SelectedRapper1Name}', Rapper2: '{SelectedRapper2Name}', IsLoading: {IsLoading}");
        
        // Basic loading/state checks
        if (IsLoading || IsFetchingInitialTopic || _latestDebateState.IsGeneratingTurn || ShowVotingModal) 
        {
            Console.WriteLine($"[Home] IsStartDisabled = true (loading/state check)");
            return true;
        }
        
        // Rapper validation
        if (string.IsNullOrEmpty(SelectedRapper1Name) || string.IsNullOrEmpty(SelectedRapper2Name)) 
        {
            Console.WriteLine($"[Home] IsStartDisabled = true (rapper not selected)");
            return true;
        }
        
        if (SelectedRapper1Name == SelectedRapper2Name) 
        {
            Console.WriteLine($"[Home] IsStartDisabled = true (same rapper)");
            return true;
        }
        
        // Topic validation - ensure there's a valid topic regardless of fetch error
        if (string.IsNullOrWhiteSpace(DebateTopicInput)) 
        {
            Console.WriteLine($"[Home] IsStartDisabled = true (topic is whitespace)");
            return true;
        }
        
        Console.WriteLine($"[Home] IsStartDisabled = false (all checks passed!)");
        return false;
    }

    private void OnRapperChanged()
    {
        Console.WriteLine($"[Home] OnRapperChanged callback fired! Rapper1: '{SelectedRapper1Name}', Rapper2: '{SelectedRapper2Name}'");
        Console.WriteLine($"[Home] Button should be enabled: {!IsStartDisabled()}");
        StateHasChanged(); // Force re-render
    }

    private void OnTopicChanged()
    {
        Console.WriteLine($"[Home] OnTopicChanged callback fired! Topic is now: '{DebateTopicInput}' (Length: {DebateTopicInput?.Length ?? 0})");
        Console.WriteLine($"[Home] Button should be enabled: {!IsStartDisabled()}");
        StateHasChanged(); // Force re-render
    }

    private async Task StartDebate()
    {
        if (IsStartDisabled()) return;
        
        // Trigger haptic feedback for debate start
        try
        {
            await JSRuntime.InvokeVoidAsync("haptic.success");
        }
        catch { /* Haptic not supported */ }
        
        _latestDebateState.IsGeneratingTurn = true;
        _lastPlayedTurnNumber = -1; // Reset audio tracking for new debate
        ShowVotingModal = false;
        LoadingErrorMessage = null;
        InitialTopicFetchError = null;
        _isSetupCollapsed = true; // Collapse setup when debate starts
        _turnHistory.Clear(); // Clear turn history for new debate
        _displayedTurnNumber = 0;
        StateHasChanged();

        var rapper1 = Rappers?.FirstOrDefault(r => r.Name == SelectedRapper1Name);
        var rapper2 = Rappers?.FirstOrDefault(r => r.Name == SelectedRapper2Name);
        var topic = new Topic { Title = DebateTopicInput.Trim(), Category = "Custom" };

        // Add detailed debugging
        Logger.LogInformation("StartDebate: Looking for rappers. Selected1: '{R1}', Selected2: '{R2}'", 
            SelectedRapper1Name ?? "NULL", SelectedRapper2Name ?? "NULL");
        
        if (Rappers != null)
        {
            Logger.LogInformation("StartDebate: Available rappers: {RapperNames}", 
                string.Join(", ", Rappers.Select(r => $"'{r.Name}'")));
        }
        else
        {
            Logger.LogError("StartDebate: Rappers list is NULL!");
        }

        Logger.LogInformation("StartDebate: Found rapper1: {R1}, Found rapper2: {R2}", 
            rapper1?.Name ?? "NULL", rapper2?.Name ?? "NULL");

        if (rapper1 == null || rapper2 == null)
        {
            Logger.LogError("Failed to find selected rappers.");
            LoadingErrorMessage = "Selected rapper(s) not found.";
            NotificationService.Notify(NotificationSeverity.Error, "Error", "Could not find selected rappers", 5000);
            _latestDebateState.IsGeneratingTurn = false;
            StateHasChanged();
            return;
        }

        Logger.LogInformation("Begin Debate clicked. Rapper1: {R1}, Rapper2: {R2}, Topic: {T}",
            rapper1.Name, rapper2.Name, topic.Title);

        // Show notification for battle start
        NotificationService.Notify(NotificationSeverity.Info, "üé§ Battle Starting!", 
            $"{rapper1.Name} vs {rapper2.Name} - Topic: {topic.Title.Substring(0, Math.Min(30, topic.Title.Length))}...", 4000);

        try
        {
            var request = new StartDebateRequest { Rapper1 = rapper1, Rapper2 = rapper2, Topic = topic };
            var response = await Http.PostAsJsonAsync("api/Debate", request);
            response.EnsureSuccessStatusCode();
            var initialState = await response.Content.ReadFromJsonAsync<DebateState>();

            if(initialState != null)
            {
                _latestDebateState = initialState;
                Logger.LogInformation("StartDebate: Received initial state from server. IsDebateInProgress: {InProg}, IsGeneratingTurn: {Gen}, CurrentTurnText: '{Text}'",
                    initialState.IsDebateInProgress, initialState.IsGeneratingTurn, initialState.CurrentTurnText);
                _ = Task.Run(async () => await PollDebateState());
            }
            else
            {
                throw new Exception("Failed to deserialize initial debate state.");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during debate setup or start.");
            _latestDebateState = CreateEmptyDebateState(); // Reset state
            LoadingErrorMessage = $"Error starting debate: {ex.Message}";
            NotificationService.Notify(NotificationSeverity.Error, "Battle Failed", ex.Message, 6000);
            StateHasChanged();
        }
    }

    private async Task StopDebate()
    {
        Logger.LogInformation("STOP DEBATE button clicked.");
        try
        {
            await JSRuntime.InvokeVoidAsync("stopAudio");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error invoking JS stopAudio function.");
        }
        await Http.PostAsync("Debate/reset", null);
        NotificationService.Notify(NotificationSeverity.Warning, "Battle Stopped", "The debate has been cancelled", 3000);
        ResetDebateState();
    }

    private async Task QuickBattle()
    {
        Logger.LogInformation("Quick Battle clicked!");
        
        // Trigger haptic feedback for quick battle
        try
        {
            await JSRuntime.InvokeVoidAsync("haptic.medium");
        }
        catch { /* Haptic not supported */ }
        
        if (Rappers == null || Rappers.Count < 2)
        {
            Logger.LogWarning("Not enough rappers for quick battle.");
            return;
        }

        // Randomly select two different rappers
        var random = new Random();
        var shuffled = Rappers.OrderBy(x => random.Next()).ToList();
        
        SelectedRapper1Name = shuffled[0].Name;
        SelectedRapper2Name = shuffled[1].Name;

        Logger.LogInformation("Quick Battle: Selected {R1} vs {R2} on topic '{Topic}'", 
            SelectedRapper1Name, SelectedRapper2Name, DebateTopicInput);

        // Topic should already be pre-populated from initialization
        // Start the debate immediately
        await StartDebate();
    }

    private async Task UpdateWinLossRecord(Rapper winner, Rapper loser)
    {
        try
        {
            var response = await Http.PostAsync($"Rappers/update-win-loss?winnerName={winner.Name}&loserName={loser.Name}", null);
            response.EnsureSuccessStatusCode();
            Logger.LogInformation("Win/loss record updated for winner {WinnerName}.", winner.Name);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating win/loss record for Winner: {WinnerName}, Loser: {LoserName}", winner.Name, loser.Name);
        }
    }

    private void ResetDebateState()
    {
        Logger.LogInformation("ResetDebateState called. Resetting UI state.");
        _latestDebateState = CreateEmptyDebateState();
        _lastPlayedTurnNumber = -1; // Reset audio tracking
        _turnHistory.Clear(); // Clear turn history
        _displayedTurnNumber = 0; // Reset to live view
        ShowVotingModal = false;
        
        // Reset crowd reaction state
        _showCrowdReaction = false;
        _currentReactionType = CrowdReactionType.None;
        _currentReactionScore = 0;
        _lastReactionTurn = -1;
        
        StateHasChanged();
    }

    // Turn navigation helper methods
    private string GetDisplayedTurnText()
    {
        if (_displayedTurnNumber == 0 || _displayedTurnNumber == _latestDebateState.CurrentTurnNumber)
        {
            // Show live turn
            return _latestDebateState.CurrentTurnText;
        }
        
        // Show historical turn
        var history = _turnHistory.FirstOrDefault(t => t.TurnNumber == _displayedTurnNumber);
        return history?.TurnText ?? _latestDebateState.CurrentTurnText;
    }

    private bool GetDisplayedIsRapper1Active()
    {
        if (_displayedTurnNumber == 0 || _displayedTurnNumber == _latestDebateState.CurrentTurnNumber)
        {
            return _latestDebateState.IsRapper1Turn;
        }
        
        var history = _turnHistory.FirstOrDefault(t => t.TurnNumber == _displayedTurnNumber);
        return history?.IsRapper1Turn ?? _latestDebateState.IsRapper1Turn;
    }

    private int GetDisplayedTurnNumber()
    {
        return _displayedTurnNumber == 0 ? _latestDebateState.CurrentTurnNumber : _displayedTurnNumber;
    }

    private Task HandleTurnNavigation(int turnNumber)
    {
        Logger.LogInformation("Navigating to turn {TurnNumber}", turnNumber);
        _displayedTurnNumber = turnNumber;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void ToggleSetup()
    {
        _isSetupCollapsed = !_isSetupCollapsed;
        StateHasChanged();
    }

    private async Task StartNewDebate()
    {
        // Reset state and expand setup
        ResetDebateState();
        _isSetupCollapsed = false;
        
        // Try to fetch a new topic
        try
        {
            var headlines = await Http.GetFromJsonAsync<List<NewsHeadline>>("api/News/headlines");
            if (headlines?.FirstOrDefault()?.Title is { Length: > 0 } newTopic)
            {
                DebateTopicInput = newTopic.Trim();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error fetching new topic for new debate.");
        }
        
        StateHasChanged();
    }

    private static DebateState CreateEmptyDebateState()
    {
        return new DebateState
        {
            Rapper1 = new Rapper(),
            Rapper2 = new Rapper(),
            Topic = new Topic(),
            CurrentTurnAudio = Array.Empty<byte>(),
            WinnerName = string.Empty,
            JudgeReasoning = string.Empty,
            Stats = new DebateStats(),
            ErrorMessage = string.Empty,
            RhymeAnalytics = null,
            CurrentTurnAnalytics = null
        };
    }

    public void Dispose()
    {
         objRef?.Dispose();
        Logger.LogDebug("Home page disposed.");
        GC.SuppressFinalize(this);
    }
}
