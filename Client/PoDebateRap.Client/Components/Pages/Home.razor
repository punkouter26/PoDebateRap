@page "/"
@using PoDebateRap.Shared.Models
@using PoDebateRap.Client.Components.Debate
@using Microsoft.JSInterop
@using System.Net.Http.Json

@inject HttpClient Http
@inject ILogger<Home> Logger
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>PoDebateRap</PageTitle>

<div class="page-container">
    <!-- Header Section -->
    <div class="header-section">
        <h1 class="main-title">PoDebateRap</h1>
        <p class="subtitle">AI-Powered Rap Battle Arena</p>
    </div>

    @* Display loading error if any *@
    @if (LoadingErrorMessage is { Length: > 0 })
    {
        <div class="alert alert-error" role="alert">
            <span class="alert-icon">‚ö†Ô∏è</span>
            <div class="alert-content">
                <strong>Error Loading Application</strong>
                <p>@LoadingErrorMessage</p>
            </div>
        </div>
    }

    <!-- Collapsible Setup Section -->
    <div class="setup-wrapper @(_isSetupCollapsed ? "collapsed" : "")">
        @if (!_isSetupCollapsed)
        {
            <DebateSetup Rappers="Rappers"
                     @bind-SelectedRapper1Name="SelectedRapper1Name"
                     @bind-SelectedRapper2Name="SelectedRapper2Name"
                     @bind-DebateTopicInput="DebateTopicInput"
                     @bind-DebateTopicInput:after="OnTopicChanged"
                     IsDisabled="@(IsLoading || _latestDebateState.IsGeneratingTurn || _latestDebateState.IsDebateInProgress)"
                     IsLoading="IsLoading"
                     IsStarting="_latestDebateState.IsGeneratingTurn"
                     IsFetchingTopic="IsFetchingInitialTopic"
                     IsDebateInProgress="_latestDebateState.IsDebateInProgress"
                     IsVoting="ShowVotingModal"
                     IsStartDisabled="IsStartDisabled()"
                     InitialTopicFetchError="InitialTopicFetchError"
                     TopicPlaceholder="@(IsFetchingInitialTopic ? "Fetching news topic..." : "Enter debate topic...")"
                     OnStartDebate="StartDebate"
                     OnStopDebate="StopDebate"
                     OnQuickBattle="QuickBattle" />
        }
        else
        {
            <!-- Collapsed Summary Bar -->
            <div class="setup-collapsed-summary" @onclick="ToggleSetup">
                <div class="summary-content">
                    <span class="summary-icon">‚öîÔ∏è</span>
                    <span class="summary-text">
                        <strong>@(_latestDebateState.Rapper1?.Name ?? "Rapper 1")</strong> vs 
                        <strong>@(_latestDebateState.Rapper2?.Name ?? "Rapper 2")</strong>
                        @if (_latestDebateState.Topic?.Title is { Length: > 0 } topicTitle)
                        {
                            <span class="summary-topic">- @topicTitle</span>
                        }
                    </span>
                </div>
                <button class="toggle-btn" title="Expand setup">
                    <span>‚ñº</span>
                </button>
            </div>
        }
    </div>

    <!-- Floating Action Button (shows when setup is collapsed and debate finished) -->
    @if (_isSetupCollapsed && !_latestDebateState.IsDebateInProgress)
    {
        <button class="fab-new-debate" @onclick="StartNewDebate" title="Start New Debate">
            <span class="fab-icon">‚ûï</span>
            <span class="fab-text">New Debate</span>
        </button>
    }

    <!-- Debate Arena Section -->
    <div class="debate-arena-container">
        @if (_latestDebateState.IsDebateInProgress || _latestDebateState.IsDebateFinished)
        {
            <DebateVisualizer Rapper1="@_latestDebateState.Rapper1"
                              Rapper2="@_latestDebateState.Rapper2"
                              CurrentTurnText="@GetDisplayedTurnText()"
                              IsRapper1Active="@GetDisplayedIsRapper1Active()"
                              IsRapper2Active="@(!GetDisplayedIsRapper1Active())"
                              CurrentTurnNumber="@GetDisplayedTurnNumber()"
                              TotalTurns="@_latestDebateState.TotalTurns"
                              ShowNavigation="@_latestDebateState.IsDebateFinished"
                              OnTurnChanged="HandleTurnNavigation" />
            
            <!-- Inline Results Section -->
            @if (ShowVotingModal && _latestDebateState.IsDebateFinished)
            {
                <div class="inline-results" id="debate-results">
                    <div class="results-header">
                        <h3>ÔøΩ Debate Results</h3>
                    </div>
                    
                    <div class="results-body">
                        <p class="results-intro">
                            The debate on '<strong>@(_latestDebateState.Topic?.Title ?? "the topic")</strong>' between 
                            <strong>@(_latestDebateState.Rapper1?.Name ?? "Rapper 1")</strong> and 
                            <strong>@(_latestDebateState.Rapper2?.Name ?? "Rapper 2")</strong> has concluded.
                        </p>
                        
                        <div class="judge-decision">
                            <h4>Judge's Decision:</h4>
                            @{
                                var winner = _latestDebateState.WinnerName switch
                                {
                                    { Length: > 0 } name when name is not ("Draw" or "Undecided" or "Error Judging" or "Error Parsing" or "Stats Error") => name,
                                    _ => null
                                };
                            }
                            @if (winner is not null)
                            {
                                <p class="winner-announcement">
                                    <span class="winner-icon">üëë</span>
                                    <strong>@winner wins!</strong>
                                </p>
                            }
                            else
                            {
                                <p class="@(_latestDebateState.WinnerName switch
                                {
                                    "Draw" => "draw-announcement",
                                    "Undecided" => "undecided-announcement",
                                    _ => "error-announcement"
                                })">
                                    @(_latestDebateState.WinnerName switch
                                    {
                                        "Draw" => "‚öñÔ∏è It's a Draw!",
                                        "Undecided" => "ü§î The judge was undecided.",
                                        _ => "‚ö†Ô∏è There was an error determining the winner."
                                    })
                                </p>
                            }
                            
                            @if (_latestDebateState.JudgeReasoning is { Length: > 0 } reasoning)
                            {
                                <div class="judge-reasoning">
                                    <p>"@reasoning"</p>
                                </div>
                            }
                        </div>
                        
                        @if (_latestDebateState.Stats != null)
                        {
                            <div class="debate-stats">
                                <h5>Debate Stats (1-5)</h5>
                                <table class="stats-table">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>@(_latestDebateState.Rapper1?.Name ?? "Rapper 1")</th>
                                            <th>@(_latestDebateState.Rapper2?.Name ?? "Rapper 2")</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Logic</td>
                                            <td>@_latestDebateState.Stats.Rapper1LogicScore</td>
                                            <td>@_latestDebateState.Stats.Rapper2LogicScore</td>
                                        </tr>
                                        <tr>
                                            <td>Sentiment</td>
                                            <td>@_latestDebateState.Stats.Rapper1SentimentScore</td>
                                            <td>@_latestDebateState.Stats.Rapper2SentimentScore</td>
                                        </tr>
                                        <tr>
                                            <td>Adherence</td>
                                            <td>@_latestDebateState.Stats.Rapper1AdherenceScore</td>
                                            <td>@_latestDebateState.Stats.Rapper2AdherenceScore</td>
                                        </tr>
                                        <tr>
                                            <td>Rebuttal</td>
                                            <td>@_latestDebateState.Stats.Rapper1RebuttalScore</td>
                                            <td>@_latestDebateState.Stats.Rapper2RebuttalScore</td>
                                        </tr>
                                        <tr class="total-row">
                                            <td><strong>TOTAL</strong></td>
                                            <td><strong>@_latestDebateState.Stats.Rapper1TotalScore</strong></td>
                                            <td><strong>@_latestDebateState.Stats.Rapper2TotalScore</strong></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        }
                    </div>
                </div>
            }
        }
        else
        {
            <div class="empty-state">
                <div class="empty-state-icon">üé§</div>
                <h3>Ready to Battle?</h3>
                <p>Select two rappers and choose a debate topic to start an epic AI rap battle!</p>
            </div>
        }
    </div>

    <!-- Mini Leaderboard Widget -->
    <MiniLeaderboard Rappers="Rappers" IsLoading="IsLoading" />

    <!-- Remove the old modal - results are now inline -->
    @* Results Modal removed - using inline display instead *@

</div> @* End page-container *@



@code {
    private DotNetObjectReference<Home>? objRef;
    private DebateState _latestDebateState = CreateEmptyDebateState();
    private int _lastPlayedTurnNumber = -1; // Track which turn's audio we've already played
    private bool _isSetupCollapsed = false; // Track collapse state
    
    // Turn history for navigation
    private record TurnHistory(int TurnNumber, string TurnText, bool IsRapper1Turn);
    private List<TurnHistory> _turnHistory = new();
    private int _displayedTurnNumber = 0; // Track which turn is currently displayed (0 = live)

    private List<Rapper>? Rappers;
    private string? SelectedRapper1Name;
    private string? SelectedRapper2Name;
    
    // Use backing field to ensure StateHasChanged is called when topic changes
    private string _debateTopicInput = "";
    private string DebateTopicInput 
    { 
        get => _debateTopicInput;
        set
        {
            if (_debateTopicInput != value)
            {
                _debateTopicInput = value;
                Console.WriteLine($"[Home] DebateTopicInput property setter called with: '{value}'");
                StateHasChanged(); // Force re-render to update button state
            }
        }
    }

    private bool IsLoading = true;
    private bool IsFetchingInitialTopic = false;
    private string? LoadingErrorMessage = null;
#pragma warning disable CS0414 // Field is used - passed to DebateSetup component parameter
    private string? InitialTopicFetchError = null;
#pragma warning restore CS0414

    private bool ShowVotingModal = false;

    private static class ThemeVariables
    {
        public const string HeaderFont = "'Impact', Haettenschweiler, 'Arial Narrow Bold', sans-serif";
        public const string PrimaryColor = "#FFD700"; // Using Gold for primary theme accent
        public const string AccentColor = "#CD7F32"; // Bronze for VS separator
    }

    protected override async Task OnInitializedAsync()
    {
        objRef = DotNetObjectReference.Create(this);
        Logger.LogInformation("Home page initializing.");
        IsLoading = true;
        IsFetchingInitialTopic = true;
        LoadingErrorMessage = null;
        InitialTopicFetchError = null;
        StateHasChanged();

        try
        {
            // Add timeout and better error handling for Rappers API
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
            
            Rappers = await Http.GetFromJsonAsync<List<Rapper>>("Rappers", cts.Token);
            Logger.LogDebug("Retrieved {LoadedRapperCount} rappers.", Rappers?.Count ?? 0);
            
            // Add detailed logging for debugging
            if (Rappers != null && Rappers.Count > 0)
            {
                Logger.LogInformation("Successfully loaded {Count} rappers: {RapperNames}", 
                    Rappers.Count, 
                    string.Join(", ", Rappers.Select(r => $"'{r.Name}'")));
            }
            else
            {
                Logger.LogWarning("Rappers list is null or empty after API call");
            }
            
            if (Rappers == null || Rappers.Count == 0)
            {
                 LoadingErrorMessage = "Rapper list is empty. Check server connection and data seeding.";
                 Logger.LogWarning(LoadingErrorMessage);
            }

            try
            {
                var headlines = await Http.GetFromJsonAsync<List<NewsHeadline>>("News/headlines", cts.Token);
                if (headlines != null && headlines.Count > 0 && !string.IsNullOrWhiteSpace(headlines[0].Title))
                {
                    DebateTopicInput = headlines[0].Title!.Trim();
                    InitialTopicFetchError = null;
                    Logger.LogInformation("Pre-populated topic from news: {NewsTopic}", DebateTopicInput);
                }
                else
                {
                    // Leave blank for user to fill in
                    DebateTopicInput = "";
                    InitialTopicFetchError = "No news topics available. Please enter a topic manually.";
                    Logger.LogWarning("News API returned no headlines or headline had no title.");
                }
            }
            catch (HttpRequestException httpEx)
            {
                 Logger.LogError(httpEx, "HTTP error fetching initial news topic from API.");
                 // Leave blank for user to fill in
                 DebateTopicInput = "";
                 InitialTopicFetchError = "News service unavailable. Please enter a topic manually.";
            }
            catch (TaskCanceledException)
            {
                 Logger.LogError("Timeout fetching initial news topic from API.");
                 // Leave blank for user to fill in
                 DebateTopicInput = "";
                 InitialTopicFetchError = "News service timeout. Please enter a topic manually.";
            }
            catch (Exception newsEx)
            {
                 Logger.LogError(newsEx, "Error fetching initial news topic from API.");
                 // Leave blank for user to fill in
                 DebateTopicInput = "";
                 InitialTopicFetchError = "Could not fetch news topic. Please enter a topic manually.";
            }
        }
        catch (HttpRequestException httpEx)
        {
            Logger.LogError(httpEx, "HTTP error loading initial data for Home page.");
            LoadingErrorMessage = $"Could not connect to server: {httpEx.Message}. Please check if the API server is running.";
        }
        catch (TaskCanceledException)
        {
            Logger.LogError("Timeout loading initial data for Home page.");
            LoadingErrorMessage = "Server request timed out. Please check your connection and try again.";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading initial data for Home page.");
            LoadingErrorMessage = $"Error loading initial data: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
            IsFetchingInitialTopic = false;
            StateHasChanged();
        }
    }

    private async Task PollDebateState()
    {
        try
        {
            var newState = await Http.GetFromJsonAsync<DebateState>("Debate/state");

            if (newState == null)
            {
                Logger.LogWarning("Received null debate state from API. Stopping polling.");
                _latestDebateState = CreateEmptyDebateState(); // Reset state
                LoadingErrorMessage = "Debate state could not be retrieved.";
                await InvokeAsync(StateHasChanged);
                return;
            }

            _latestDebateState = newState;
            Logger.LogInformation("Received state update. Turn: {Turn}, IsGenerating: {IsGenerating}, Winner: {Winner}, CurrentTurnText length: {TextLength}",
                newState.CurrentTurnNumber, newState.IsGeneratingTurn, newState.WinnerName ?? "N/A", newState.CurrentTurnText?.Length ?? 0);

            // Capture turn history for navigation (only if it's a new turn with content)
            if (newState.CurrentTurnNumber > 0 && 
                !string.IsNullOrEmpty(newState.CurrentTurnText) &&
                !_turnHistory.Any(t => t.TurnNumber == newState.CurrentTurnNumber))
            {
                _turnHistory.Add(new TurnHistory(
                    newState.CurrentTurnNumber,
                    newState.CurrentTurnText,
                    newState.IsRapper1Turn
                ));
                Logger.LogInformation("üìö Captured turn {Turn} in history. Total turns stored: {Count}", 
                    newState.CurrentTurnNumber, _turnHistory.Count);
            }
            
            // Reset to live view when new turn comes in
            if (_displayedTurnNumber != 0 && _displayedTurnNumber != newState.CurrentTurnNumber)
            {
                _displayedTurnNumber = 0; // Back to live view
            }

            // Log audio data info
            if (newState.CurrentTurnAudio != null)
            {
                Logger.LogInformation("üéµ Audio data present: Length={Length} bytes", newState.CurrentTurnAudio.Length);
                
                // Log first 50 bytes for debugging
                if (newState.CurrentTurnAudio.Length > 0)
                {
                    var first50 = string.Join(" ", newState.CurrentTurnAudio.Take(50).Select(b => b.ToString("X2")));
                    Logger.LogInformation("üîç First 50 bytes received: {Bytes}", first50);
                }
            }
            else
            {
                Logger.LogWarning("‚ö†Ô∏è No audio data in state");
            }

            // Only play audio if this is a new turn we haven't played yet
            if (newState.CurrentTurnAudio != null && newState.CurrentTurnAudio.Length > 0 && objRef != null && newState.CurrentTurnNumber != _lastPlayedTurnNumber)
            {
                Logger.LogInformation("üéµ Audio data received for turn {Turn} (length: {AudioLength}), attempting playback via JS interop.", newState.CurrentTurnNumber, newState.CurrentTurnAudio.Length);
                
                // Trigger haptic feedback for turn transition
                try
                {
                    await JSRuntime.InvokeVoidAsync("haptic.notification");
                }
                catch { /* Haptic not supported */ }
                
                try
                {
                    var base64Audio = Convert.ToBase64String(newState.CurrentTurnAudio);
                    Logger.LogInformation("üéµ Converted to base64, length: {Base64Length}", base64Audio.Length);
                    await JSRuntime.InvokeVoidAsync("playAudio", objRef, base64Audio);
                    _lastPlayedTurnNumber = newState.CurrentTurnNumber; // Mark this turn as played
                    Logger.LogInformation("‚úÖ JS playAudio invoked successfully");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "‚ùå Error invoking JS for audio playback for turn {Turn}. Signaling completion.", newState.CurrentTurnNumber);
                    await NotifyAudioPlaybackComplete();
                }
            }
            else if (newState.CurrentTurnNumber == _lastPlayedTurnNumber && newState.CurrentTurnAudio != null)
            {
                Logger.LogDebug("‚è≠Ô∏è Skipping audio playback for turn {Turn} - already played", newState.CurrentTurnNumber);
            }
            else if (newState.IsDebateInProgress && newState.CurrentTurnNumber > 0)
            {
                Logger.LogInformation("No audio data for turn {Turn} or audio length is zero. Signaling completion immediately.", newState.CurrentTurnNumber);
                await NotifyAudioPlaybackComplete();
            }
            else if (newState.IsDebateInProgress && newState.CurrentTurnNumber == 0)
            {
                Logger.LogInformation("Initial state received (Turn 0), no audio expected yet. Waiting for first turn.");
            }
            else
            {
                Logger.LogInformation("No audio data and not in progress. No action needed for audio playback.");
            }

            if (!string.IsNullOrEmpty(newState.ErrorMessage))
            {
                 Logger.LogError("Error from orchestrator: {Error}", newState.ErrorMessage);
                 // TODO: Show error message in UI
            }

            await InvokeAsync(StateHasChanged);

            Logger.LogInformation("PollDebateState: Checking polling condition. IsDebateInProgress: {DS}, IsDebateFinished: {IDF}",
                _latestDebateState.IsDebateInProgress, newState.IsDebateFinished);
            if (_latestDebateState.IsDebateInProgress && !newState.IsDebateFinished)
            {
                Logger.LogInformation("PollDebateState: Scheduling next poll.");
                _ = Task.Delay(1000).ContinueWith(async _ => await PollDebateState());
            }
            else
            {
                Logger.LogInformation("PollDebateState: Not scheduling next poll. IsDebateInProgress: {DS}, IsDebateFinished: {IDF}",
                    _latestDebateState.IsDebateInProgress, newState.IsDebateFinished);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error polling debate state.");
            _latestDebateState = CreateEmptyDebateState(); // Reset state
            LoadingErrorMessage = $"Error during debate: {ex.Message}";
            await InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task NotifyAudioPlaybackComplete()
    {
        Logger.LogInformation("NotifyAudioPlaybackComplete called from JavaScript.");
        try
        {
            Logger.LogInformation("Signaling audio playback complete to server.");
            var response = await Http.PostAsync("Debate/signal-audio-complete", null);
            response.EnsureSuccessStatusCode();
            Logger.LogInformation("Server acknowledged audio playback complete.");

            if (_latestDebateState.IsDebateFinished)
            {
                Logger.LogInformation("Audio playback complete AND debate is finished. Showing results modal.");
                ShowVotingModal = true;
                
                // Trigger victory haptic feedback
                try
                {
                    await JSRuntime.InvokeVoidAsync("haptic.victory");
                }
                catch { /* Haptic not supported */ }
                
                await InvokeAsync(StateHasChanged);
                
                // Scroll to results section
                try
                {
                    await Task.Delay(100); // Small delay to ensure DOM is updated
                    await JSRuntime.InvokeVoidAsync("scrollToElement", "debate-results");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error scrolling to results.");
                }
            }
            else if (_latestDebateState.IsDebateInProgress)
            {
                _ = Task.Run(async () => await PollDebateState());
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error signaling audio playback completion to orchestrator.");
        }
    }

    private bool IsStartDisabled()
    {
        Console.WriteLine($"[Home] IsStartDisabled called. Topic: '{DebateTopicInput}', Rapper1: '{SelectedRapper1Name}', Rapper2: '{SelectedRapper2Name}', IsLoading: {IsLoading}");
        
        // Basic loading/state checks
        if (IsLoading || IsFetchingInitialTopic || _latestDebateState.IsGeneratingTurn || ShowVotingModal) 
        {
            Console.WriteLine($"[Home] IsStartDisabled = true (loading/state check)");
            return true;
        }
        
        // Rapper validation
        if (string.IsNullOrEmpty(SelectedRapper1Name) || string.IsNullOrEmpty(SelectedRapper2Name)) 
        {
            Console.WriteLine($"[Home] IsStartDisabled = true (rapper not selected)");
            return true;
        }
        
        if (SelectedRapper1Name == SelectedRapper2Name) 
        {
            Console.WriteLine($"[Home] IsStartDisabled = true (same rapper)");
            return true;
        }
        
        // Topic validation - ensure there's a valid topic regardless of fetch error
        if (string.IsNullOrWhiteSpace(DebateTopicInput)) 
        {
            Console.WriteLine($"[Home] IsStartDisabled = true (topic is whitespace)");
            return true;
        }
        
        Console.WriteLine($"[Home] IsStartDisabled = false (all checks passed!)");
        return false;
    }

    private void OnRapperChanged()
    {
        Console.WriteLine($"[Home] OnRapperChanged callback fired! Rapper1: '{SelectedRapper1Name}', Rapper2: '{SelectedRapper2Name}'");
        Console.WriteLine($"[Home] Button should be enabled: {!IsStartDisabled()}");
        StateHasChanged(); // Force re-render
    }

    private void OnTopicChanged()
    {
        Console.WriteLine($"[Home] OnTopicChanged callback fired! Topic is now: '{DebateTopicInput}' (Length: {DebateTopicInput?.Length ?? 0})");
        Console.WriteLine($"[Home] Button should be enabled: {!IsStartDisabled()}");
        StateHasChanged(); // Force re-render
    }

    private async Task StartDebate()
    {
        if (IsStartDisabled()) return;
        
        // Trigger haptic feedback for debate start
        try
        {
            await JSRuntime.InvokeVoidAsync("haptic.success");
        }
        catch { /* Haptic not supported */ }
        
        _latestDebateState.IsGeneratingTurn = true;
        _lastPlayedTurnNumber = -1; // Reset audio tracking for new debate
        ShowVotingModal = false;
        LoadingErrorMessage = null;
        InitialTopicFetchError = null;
        _isSetupCollapsed = true; // Collapse setup when debate starts
        StateHasChanged();

        var rapper1 = Rappers?.FirstOrDefault(r => r.Name == SelectedRapper1Name);
        var rapper2 = Rappers?.FirstOrDefault(r => r.Name == SelectedRapper2Name);
        var topic = new Topic { Title = DebateTopicInput.Trim(), Category = "Custom" };

        // Add detailed debugging
        Logger.LogInformation("StartDebate: Looking for rappers. Selected1: '{R1}', Selected2: '{R2}'", 
            SelectedRapper1Name ?? "NULL", SelectedRapper2Name ?? "NULL");
        
        if (Rappers != null)
        {
            Logger.LogInformation("StartDebate: Available rappers: {RapperNames}", 
                string.Join(", ", Rappers.Select(r => $"'{r.Name}'")));
        }
        else
        {
            Logger.LogError("StartDebate: Rappers list is NULL!");
        }

        Logger.LogInformation("StartDebate: Found rapper1: {R1}, Found rapper2: {R2}", 
            rapper1?.Name ?? "NULL", rapper2?.Name ?? "NULL");

        if (rapper1 == null || rapper2 == null)
        {
            Logger.LogError("Failed to find selected rappers.");
            LoadingErrorMessage = "Selected rapper(s) not found.";
            _latestDebateState.IsGeneratingTurn = false;
            StateHasChanged();
            return;
        }

        Logger.LogInformation("Begin Debate clicked. Rapper1: {R1}, Rapper2: {R2}, Topic: {T}",
            rapper1.Name, rapper2.Name, topic.Title);

        try
        {
            var request = new StartDebateRequest { Rapper1 = rapper1, Rapper2 = rapper2, Topic = topic };
            var response = await Http.PostAsJsonAsync("Debate/start", request);
            response.EnsureSuccessStatusCode();
            var initialState = await response.Content.ReadFromJsonAsync<DebateState>();

            if(initialState != null)
            {
                _latestDebateState = initialState;
                Logger.LogInformation("StartDebate: Received initial state from server. IsDebateInProgress: {InProg}, IsGeneratingTurn: {Gen}, CurrentTurnText: '{Text}'",
                    initialState.IsDebateInProgress, initialState.IsGeneratingTurn, initialState.CurrentTurnText);
                _ = Task.Run(async () => await PollDebateState());
            }
            else
            {
                throw new Exception("Failed to deserialize initial debate state.");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during debate setup or start.");
            _latestDebateState = CreateEmptyDebateState(); // Reset state
            LoadingErrorMessage = $"Error starting debate: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task StopDebate()
    {
        Logger.LogInformation("STOP DEBATE button clicked.");
        try
        {
            await JSRuntime.InvokeVoidAsync("stopAudio");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error invoking JS stopAudio function.");
        }
        await Http.PostAsync("Debate/reset", null);
        ResetDebateState();
    }

    private async Task QuickBattle()
    {
        Logger.LogInformation("Quick Battle clicked!");
        
        // Trigger haptic feedback for quick battle
        try
        {
            await JSRuntime.InvokeVoidAsync("haptic.medium");
        }
        catch { /* Haptic not supported */ }
        
        if (Rappers == null || Rappers.Count < 2)
        {
            Logger.LogWarning("Not enough rappers for quick battle.");
            return;
        }

        // Randomly select two different rappers
        var random = new Random();
        var shuffled = Rappers.OrderBy(x => random.Next()).ToList();
        
        SelectedRapper1Name = shuffled[0].Name;
        SelectedRapper2Name = shuffled[1].Name;

        Logger.LogInformation("Quick Battle: Selected {R1} vs {R2} on topic '{Topic}'", 
            SelectedRapper1Name, SelectedRapper2Name, DebateTopicInput);

        // Topic should already be pre-populated from initialization
        // Start the debate immediately
        await StartDebate();
    }

    private void HandleResultsModalClosed()
    {
        ShowVotingModal = false;
        Logger.LogInformation("Results display acknowledged.");

        var (winnerRapper, loserRapper) = (_latestDebateState.WinnerName, _latestDebateState.Rapper1, _latestDebateState.Rapper2) switch
        {
            ({ Length: > 0 } winnerName, { } r1, { } r2) when winnerName is not ("Draw" or "Undecided" or "Error Judging" or "Error Parsing" or "Stats Error") =>
                winnerName == r1.Name ? (r1, r2) : winnerName == r2.Name ? (r2, r1) : (null, null),
            _ => (null, null)
        };

        if (winnerRapper is not null && loserRapper is not null)
        {
            _ = Task.Run(async () => await UpdateWinLossRecord(winnerRapper, loserRapper));
        }
        else
        {
            Logger.LogInformation("No valid winner determined by AI judge ({WinnerName}). Skipping win/loss update.", _latestDebateState.WinnerName ?? "N/A");
        }

        ResetDebateState();
    }

    private async Task UpdateWinLossRecord(Rapper winner, Rapper loser)
    {
        try
        {
            var response = await Http.PostAsync($"Rappers/update-win-loss?winnerName={winner.Name}&loserName={loser.Name}", null);
            response.EnsureSuccessStatusCode();
            Logger.LogInformation("Win/loss record updated for winner {WinnerName}.", winner.Name);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating win/loss record for Winner: {WinnerName}, Loser: {LoserName}", winner.Name, loser.Name);
        }
    }

    private void ResetDebateState()
    {
        Logger.LogInformation("ResetDebateState called. Resetting UI state.");
        _latestDebateState = CreateEmptyDebateState();
        _lastPlayedTurnNumber = -1; // Reset audio tracking
        _turnHistory.Clear(); // Clear turn history
        _displayedTurnNumber = 0; // Reset to live view
        ShowVotingModal = false;
        StateHasChanged();
    }

    // Turn navigation helper methods
    private string GetDisplayedTurnText()
    {
        if (_displayedTurnNumber == 0 || _displayedTurnNumber == _latestDebateState.CurrentTurnNumber)
        {
            // Show live turn
            return _latestDebateState.CurrentTurnText;
        }
        
        // Show historical turn
        var history = _turnHistory.FirstOrDefault(t => t.TurnNumber == _displayedTurnNumber);
        return history?.TurnText ?? _latestDebateState.CurrentTurnText;
    }

    private bool GetDisplayedIsRapper1Active()
    {
        if (_displayedTurnNumber == 0 || _displayedTurnNumber == _latestDebateState.CurrentTurnNumber)
        {
            return _latestDebateState.IsRapper1Turn;
        }
        
        var history = _turnHistory.FirstOrDefault(t => t.TurnNumber == _displayedTurnNumber);
        return history?.IsRapper1Turn ?? _latestDebateState.IsRapper1Turn;
    }

    private int GetDisplayedTurnNumber()
    {
        return _displayedTurnNumber == 0 ? _latestDebateState.CurrentTurnNumber : _displayedTurnNumber;
    }

    private Task HandleTurnNavigation(int turnNumber)
    {
        Logger.LogInformation("Navigating to turn {TurnNumber}", turnNumber);
        _displayedTurnNumber = turnNumber;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void ToggleSetup()
    {
        _isSetupCollapsed = !_isSetupCollapsed;
        StateHasChanged();
    }

    private async Task StartNewDebate()
    {
        // Reset state and expand setup
        ResetDebateState();
        _isSetupCollapsed = false;
        
        // Try to fetch a new topic
        try
        {
            var headlines = await Http.GetFromJsonAsync<List<NewsHeadline>>("News/headlines");
            if (headlines?.FirstOrDefault()?.Title is { Length: > 0 } newTopic)
            {
                DebateTopicInput = newTopic.Trim();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error fetching new topic for new debate.");
        }
        
        StateHasChanged();
    }

    private static DebateState CreateEmptyDebateState()
    {
        return new DebateState
        {
            Rapper1 = new Rapper(),
            Rapper2 = new Rapper(),
            Topic = new Topic(),
            CurrentTurnAudio = Array.Empty<byte>(),
            WinnerName = string.Empty,
            JudgeReasoning = string.Empty,
            Stats = new DebateStats(),
            ErrorMessage = string.Empty
        };
    }

    public void Dispose()
    {
         objRef?.Dispose();
        Logger.LogDebug("Home page disposed.");
        GC.SuppressFinalize(this);
    }
}
