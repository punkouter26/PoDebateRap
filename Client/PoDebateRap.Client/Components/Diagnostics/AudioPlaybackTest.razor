@using Radzen
@using Radzen.Blazor
@inject HttpClient Http
@inject ILogger<AudioPlaybackTest> Logger
@inject IJSRuntime JSRuntime
@inject NotificationService NotificationService

<div class="audio-test-section">
    <RadzenButton Icon="volume_up"
                  Text="@(_isTestingAudio ? "Testing..." : "Test Audio")"
                  ButtonStyle="ButtonStyle.Secondary"
                  Disabled="@_isTestingAudio"
                  Click="@TestTextToSpeech" />
</div>

@code {
    private DotNetObjectReference<AudioPlaybackTest>? _objRef;
    private bool _isTestingAudio = false;

    [Parameter]
    public EventCallback OnAudioTestComplete { get; set; }

    protected override void OnInitialized()
    {
        _objRef = DotNetObjectReference.Create(this);
    }

    private async Task TestTextToSpeech()
    {
        if (_isTestingAudio) return;
        
        _isTestingAudio = true;
        NotificationService.Notify(NotificationSeverity.Info, "Testing Audio", "Generating speech...", 2000);
        StateHasChanged();
        
        try
        {
            Logger.LogInformation("Manual TTS test button clicked");
            
            // Simple test using the TTS service via the AI controller
            var testText = "Hello! This is a text to speech test from the diagnostics page. If you can hear this, the audio system is working correctly.";
            
            // Use capitalized property names to match C# model (GenerateSpeechRequest)
            var requestBody = new { Text = testText, VoiceName = "en-US-JennyNeural" };
            var response = await Http.PostAsJsonAsync("AI/generate-speech", requestBody);
            
            if (response.IsSuccessStatusCode)
            {
                var audioBytes = await response.Content.ReadAsByteArrayAsync();
                if (audioBytes != null && audioBytes.Length > 0 && _objRef != null)
                {
                    Logger.LogInformation("‚úÖ TTS test successful. Playing audio with {Length} bytes", audioBytes.Length);
                    NotificationService.Notify(NotificationSeverity.Success, "Audio Ready", "Playing test audio...", 3000);
                    
                    // Log first 50 bytes for debugging
                    var first50 = string.Join(" ", audioBytes.Take(50).Select(b => b.ToString("X2")));
                    Logger.LogInformation("üîç First 50 bytes of audio: {Bytes}", first50);
                    
                    var base64Audio = Convert.ToBase64String(audioBytes);
                    Logger.LogInformation("üéµ Base64 length: {Length}", base64Audio.Length);
                    
                    await JSRuntime.InvokeVoidAsync("playAudio", _objRef, base64Audio);
                    Logger.LogInformation("‚úÖ Audio playback initiated");
                }
                else
                {
                    Logger.LogWarning("‚ö†Ô∏è TTS test returned no audio data");
                    NotificationService.Notify(NotificationSeverity.Warning, "No Audio", "TTS returned empty audio data", 4000);
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                Logger.LogError("‚ùå TTS test failed with status {Status}: {Error}", response.StatusCode, errorContent);
                NotificationService.Notify(NotificationSeverity.Error, "Audio Test Failed", $"Status: {response.StatusCode}", 5000);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "‚ùå Exception during manual TTS test");
            NotificationService.Notify(NotificationSeverity.Error, "Audio Test Error", ex.Message, 5000);
        }
        finally
        {
            _isTestingAudio = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task NotifyAudioPlaybackComplete()
    {
        Logger.LogInformation("Audio playback completed in AudioPlaybackTest component");
        _isTestingAudio = false;
        await OnAudioTestComplete.InvokeAsync();
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _objRef?.Dispose();
    }
}
